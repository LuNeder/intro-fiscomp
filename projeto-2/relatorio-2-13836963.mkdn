# Projeto 2
<!-- Compilar com: pandoc ./relatorio-2-13836963.mkdn --pdf-engine=lualatex -f markdown-implicit_figures -o ./relatorio-2-13836963.pdf -->

## Tarefa A
O código abaixo calcula a média <$x^n$> para uma sequência aleartória gerada.

````fortran
       iNum = 10000000
       write(*,*) 'De n'
       read(*,*) exp

       soma = 0
       do i =0,iNum
         soma = soma + rand()**exp
       end do

       div = soma/iNum

       write(*,*) 'media = ', div
       end
````

Aqui estão seis exemplos de saída:

![tarefaA](fotos/Captura-de-tela_2023-09-26_21-17-56.png)


## Tarefa B1
O código abaixo calcula um histograma do andarilho bebado após N = 1000 passos

````fortran
        dimension ia(-1001:1001)
        dimension ib(0:1)
        ia(-1001:1001) = 0
        ib(0) = 1
        ib(1) = -1
        M = 100000 ! num de andarilhos
        N = 1000 ! num de passos
        ap = 0.5e0  ! prob dir
        itot = 0 ! total de passos
        iposx = 0 ! posicao
        open(unit=1, file='saida-1')
        do j=1,M
          iposx = 0
          do i=1,N
            ir = rand()/ap ! 0 = dir 1 = esq.
C            write(*,*) ir
            iposx = iposx + ib(ir)           
          end do
C          write(*,*) 'iposx-final = ', iposx
          ia(iposx) = ia(iposx) + 1
        end do
        do k = 0-N, N
          write(1,*) k, ia(k)
        end do
        close(1)
        end
````

O histograma ficou assim:

![Histograma](fotos/histoB.png)

É perceptível que o gráfico fica centrado em torno do zero, como esperado para o caso de probabilidades iguais para esquerda e direita.

## Tarefa B2
Agora realizamos novamente a tarefa B1, mas alterando a probabilidade p para $\frac{1}{3}$, $\frac{1}{4}$ e $\frac{1}{5}$

````fortran
        dimension ia(-1001:1001)
        dimension ib(0:100)
        ia(-1001:1001) = 0
        ib(0) = 1
        ib(1:100) = -1
        M = 100000 ! num de andarilhos
        N = 1000 ! num de passos
        ap = 0.25e0  ! prob dir - Alternar entre 1/3, 1/4 e 1/5
        itot = 0 ! total de passos
        iposx = 0 ! posicao
        open(unit=1, file='saida-1')
        do j=1,M
          iposx = 0
          do i=1,N
            ir = rand()/ap ! 0 = dir 1 = esq.
            iposx = iposx + ib(ir)           
          end do
          ia(iposx) = ia(iposx) + 1
        end do
        do k = 0-N, N
          write(1,*) k, ia(k)
        end do
        close(1)
        end
````

Assim ficam os novos histogramas:

$\frac{1}{3}$:

![Histograma 1/3](fotos/histo13.png)

$\frac{1}{4}$:

![h14](fotos/histo14.png)

$\frac{1}{5}$:

![h15](fotos/histo15.png)


## Tarefa C
Este programa faz um mapa do problema dos andarilhos bêbados em 2D e, em seguida, calcula a média do módulo do vetor posição (<|$\vec{r}$|>) e o $\Delta^2$ de $\vec{r}$. O arquivo para o gráfico é salvo e as médias são impressas no stdout.

````fortran
        dimension ia(-1001:1001, -1001:1001)
        ia(-1001:1001, -1001:1001) = 0
        M = 100000 ! num de andarilhos
        N = 10000 ! num de passos
        ! ap = 0.25e0  ! prob cada - probs iguais
        iposx = 0 ! posicao x
        iposy = 0 ! posicao y
        avetr = 0 ! magnetude do vetor posicao r
        sumr = 0
        sumr2 = 0
        sx = 0
        sy = 0
        open(unit=1, file='saida-1')

        do j=1,M
          iposx = 0
          iposy = 0
          do i=1,N
            ar = rand()
            if (ar .lt. 0.25) then !+x
              iposx = iposx + 1
            else
              if (ar .lt. 0.5) then !-x
                iposx = iposx - 1
              else
                if (ar .lt. 0.75) then !+y
                  iposy = iposy + 1
                else !-y
                  iposy = iposy - 1
                end if
              end if
            end if 
          end do
          write (1, *) iposx, iposy
          ar2 = iposx**2 + iposy**2
          sx = sx + iposx
          sy = sy + iposy
          sumr2 = sumr2+ar2
          sumr = sumr + sqrt(ar2)
        end do

        close(1)
        write(*,*) '<|r|> = ', (sumr/M)
        write(*,*) '∆² = ', ((sumr2 -((sx**2) + (sy**2)))/M)
        end
````

Abaixo um exemplo da média e $\Delta^2$ para 10000 passos, seguido pelos mapas para N =10, 100, 1000, 10000, $10^5$ e $10^6$, respectivamente:

![c](fotos/c.png)

![10](fotos/c10.png)

![100](fotos/c100.png)

![1000](fotos/c1000.png)

![10000](fotos/c10000.png)

![e5](fotos/c1e5.png)

![e6](fotos/c1e6.png)

É perceptível que quanto maior o número de passos mais longe da origem os andarilhos vão, no entanto

## Tarefa D
Agora

````fortran
      dimension mapa(-1000:1000,-1000:1000)

      open(unit=7, file='grafico-13836963')

      ipdo = 1
      N = 1000 !andarilhos 
      M = 1000 !passos
      do while(ipdo.le.M)
        mapa(-1000:1000,-1000:1000) = 0

       ! tarefa C
        do j=1,N
          iposx = 0
          iposy = 0
          do i=1,ipdo
            ar = rand()
            if (ar .lt. 0.25) then !+x
              iposx = iposx + 1
            else
              if (ar .lt. 0.5) then !-x
                iposx = iposx - 1
              else
                if (ar .lt. 0.75) then !+y
                  iposy = iposy + 1
                else !-y
                  iposy = iposy - 1
                end if
              end if
            end if 
          end do
          mapa(iposx,iposy) = mapa(iposx,iposy) + 1
        end do 
        ! fim tarefa C

        an = n
        iret = 10
        e = 0

        i = 0 - M
        do while(i.lt.M)
          j = 0 - M
          do while(j.lt.M)
            apt = 0
            do k=i,i+iret
              do l=j,j+iret
                apt = apt + mapa(k,l)
              end do
            end do
            if(apt.gt.0) then
                aprob = apt/an
                e = e - aprob*log(aprob)   
            end if
            j = j + iret
          end do
          i = i + iret
        end do

        write(7,*) ipdo, e
        ipdo = ipdo + 1
      end do

      close(7)
      end
````

Veja abaixo alguns exemplos:

![Tarefa5]()

Após a mudança para dupla precisão, ficou assim (a eprec foi atualizada para se aproximar o máximo possível da função interna dlog(x), como pedido):

````fortran
      implicit real*8 (a-z)
      write(*,*) 'De x para calcular ln(x)'
      read(*,*) y
      x = y
      eprec = 0.0000000000000001
      pr = 1
      exp = 1
      aln = 0
      a = -1

      if (x .GE. 1) then
        x = 1/x
        a = 1
      end if

      do while (pr .GE. eprec) 
        pr = (((1-x)**exp)/exp)
        aln = aln + (((1-x)**exp)/exp)
        exp = exp+1
      end do

      aln = a* aln
      write(*,*) 'ln(x) = ', aln
      write(*,*) 'interno:', dlog(y)
      
      end
````

Veja alguns exemplos da nova versão:

![tarefa5-2]()


## Tarefa 6
Este código recebe um número N como entrada e calcula as raízes da expressão (z-2)^N=3. Calcula alpha e rho, e então a e b tal que z = a+bi. Por fim, escreve na tela os resultados e os formata.

````fortran
      write(*,*) 'De N'
      read(*,*) iN
      k=0
      pi = 4.*atan(1.0)

      rho = 3. ** (1./iN)

      do k = 1,iN
        alpha = (2.*k*pi)/iN
        a = (rho * cos(alpha)) + 2.
        b = rho * sin(alpha)
        write(*,1) 'z', ' = ', a, ', ', b, 'i'
1       format(a1, a3, f10.6, a2, f10.6, a1) 
      end do

      end
````

Abaixo testes para N de 1 a 7:

![tarefa6]()

## Tarefa 7
Esse programa calcula o volume de uma esfera de raio 1 e d dimensões. Primeiro ele recebe o número d de entrada. Então o programa gera 2 números aleatórios e faz a norma deles para verificar se o ponto está dentro da esfera. Isso é repetido M vezes. A razão entre a quantidade de pontos dentro da esfera e do total de pontos gerados é o volume em um quadrante. Por fim, o resultado é multiplicado pelo número de quadrantes da dimensão para obter o volume. Quanto maior o número M, maior a precisão.

````fortran
      integer d
      write(*,*) 'De d'
      read(*,*) d
      M = 999999
      dentro = 0
      total = 0
      do i = 1,M
      anorma = 0
        do j = 1,d
          anorma = anorma + rand(0)**2
        end do
               
        anorma = sqrt(anorma)
        if (anorma .LE. 1) then
          dentro = dentro +1
        end if
        total = total +1
      end do
      volume = (dentro)/(total)*(2.0d0**d)
      write(*,*) 'O Volume é', volume

      end
````

Abaixo, exemplos para 2, 3 e 4 dimensões:

![tarefa7]()

## Tarefa 8
Esse programa calcula de outra forma o volume de uma esfera de raio R e dimensão d. Além disso, salva em um arquivo o volume da dimensão d e de dimensões inferiores a d por meio de um loop.

````fortran
      integer d
      write(*,*) 'De R e d, respectivamente'
      read(*,*) R, d
      pi = 4.*atan(1.0)
      open(unit=2, file='dimensoes-esferas')

      do idim = 2,d
        volume = 0
        exp = real(idim)
        volume = ((pi**(exp/2))/gamma((exp/2)+1.0))*(R**exp)
        write(2,*) idim, volume
      end do
      
      close(2)

      end
````

Com o resultado do programa, podemos fazer um gráfico:

![grafico-1-13836963]()

