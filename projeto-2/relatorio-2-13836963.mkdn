# Projeto 2


## Tarefa A
O código abaixo calcula a média <$x^n$> para uma sequência aleartória gerada.

````fortran
       iNum = 10000000
       write(*,*) 'De n'
       read(*,*) exp

       soma = 0
       do i =0,iNum
         soma = soma + rand()**exp
       end do

       div = soma/iNum

       write(*,*) 'media = ', div
       end
````

Aqui estão seis exemplos de saída:

![tarefaA](fotos/Captura de tela_2023-09-26_21-17-56.png)


## Tarefa B1
O código abaixo calcula um histograma do andarilho bebado após N = 1000 passos

````fortran
        dimension ia(-1001:1001)
        dimension ib(0:1)
        ia(-1001:1001) = 0
        ib(0) = 1
        ib(1) = -1
        M = 100000 ! num de andarilhos
        N = 1000 ! num de passos
        ap = 0.5e0  ! prob dir
        itot = 0 ! total de passos
        iposx = 0 ! posicao
        open(unit=1, file='saida-1')
        do j=1,M
          iposx = 0
          do i=1,N
            ir = rand()/ap ! 0 = dir 1 = esq.
C            write(*,*) ir
            iposx = iposx + ib(ir)           
          end do
C          write(*,*) 'iposx-final = ', iposx
          ia(iposx) = ia(iposx) + 1
        end do
        do k = 0-N, N
          write(1,*) k, ia(k)
        end do
        close(1)
        end
````

O histograma ficou assim:

![Histograma](fotos/histoB.png)

É perceptível que o gráfico fica centrado em torno do zero, como esperado para o caso de probabilidades iguais para esquerda e direita.

## Tarefa B2
Agora realizamos novamente a tarefa B1, mas alterando a probabilidade p para $\frac{1}{3}$, $\frac{1}{4}$ e $\frac{1}{5}$

````fortran
        dimension ia(-1001:1001)
        dimension ib(0:100)
        ia(-1001:1001) = 0
        ib(0) = 1
        ib(1:100) = -1
        M = 100000 ! num de andarilhos
        N = 1000 ! num de passos
        ap = 0.25e0  ! prob dir - Alternar entre 1/3, 1/4 e 1/5
        itot = 0 ! total de passos
        iposx = 0 ! posicao
        open(unit=1, file='saida-1')
        do j=1,M
          iposx = 0
          do i=1,N
            ir = rand()/ap ! 0 = dir 1 = esq.
            iposx = iposx + ib(ir)           
          end do
          ia(iposx) = ia(iposx) + 1
        end do
        do k = 0-N, N
          write(1,*) k, ia(k)
        end do
        close(1)
        end
````

Assim ficam os novos histogramas:

$\frac{1}{3}$:

![Histograma 1/3](fotos/histo13.png)

$\frac{1}{4}$:

![h14](fotos/histo14.png)

$\frac{1}{5}$:

![h15](fotos/histo15.png)


## Tarefa 4
Este programa recebe um número como entrada e verifica se ele e os números inferiores a ele são primos. Primeiro recebe como entrada um número, e em seguida verifica por quantos números ele é divisível. Caso o númereo for divisível por apenas 2 números (1 e ele mesmo), ele é adicionado à lista de primos. Em seguida, isso é repetido para cada número menor que o inicial. Por fim, o arquivo é escrito.

````fortran
        dimension a(32768)
        
        write(*,*) 'De o numero N para ver se ele'
        write(*,*) 'e os numeros inferiores a ele sao primos'
        read(*,*) n

        i = n
        k=1
        
        do while (i .GE. 1)
          j = n
          idivs=0
          do while (j .GE. 1)
            if (mod(i, j) .eq. 0) then
              idivs = idivs+1
            end if
            j=j-1
          end do
          if (idivs .eq. 2) then
            a(k) = i
            k = k+1
          end if
          i=i-1
        end do
      open(unit=2, file='saida-1-13836963')
      write(2,*) a(1:k-1)
             
      end
````

Abaixo um exemplo de entrada e saída:

![tarefa4]()



## Tarefa 5
O código abaixo calcula o logaritmo neperiano utilizando uma série e compara o resultado com a função loh(x) inclusa no fortran. Primeiro, o programa pede o x para calcular ln(x), em seguida verifica se x é maior ou igual a 1. Caso positifo, o x é substituido pelo seu inverso para que a série possa funcionar e uma variável a é definida para indicar que o resultado será o oposto (ln(x) = -ln(1/x)). Por fim, um loop calcula o ln com a série dada até que chegue na precisão de eprec (10^-5, como solicitado). Então o programa imprime o resultado e o ln calculado pela função interna do fortran, para fins de comparação.

````fortran
      real eprec
      write(*,*) 'De x para calcular ln(x)'
      read(*,*) y
      x = y
      eprec = 0.00001
      pr = 1
      exp = 1
      aln = 0
      a = -1

      if (x .GE. 1) then
        x = 1/x
        a = 1
      end if


      do while (pr .GE. eprec) 
        pr = (((1-x)**exp)/exp)
        aln = aln + (((1-x)**exp)/exp)
        exp = exp+1
      end do


      aln = a* aln
      write(*,*) 'ln(x) = ', aln
      write(*,*) 'interno:', log(y)
      
      end
````

Veja abaixo alguns exemplos:

![Tarefa5]()

Após a mudança para dupla precisão, ficou assim (a eprec foi atualizada para se aproximar o máximo possível da função interna dlog(x), como pedido):

````fortran
      implicit real*8 (a-z)
      write(*,*) 'De x para calcular ln(x)'
      read(*,*) y
      x = y
      eprec = 0.0000000000000001
      pr = 1
      exp = 1
      aln = 0
      a = -1

      if (x .GE. 1) then
        x = 1/x
        a = 1
      end if

      do while (pr .GE. eprec) 
        pr = (((1-x)**exp)/exp)
        aln = aln + (((1-x)**exp)/exp)
        exp = exp+1
      end do

      aln = a* aln
      write(*,*) 'ln(x) = ', aln
      write(*,*) 'interno:', dlog(y)
      
      end
````

Veja alguns exemplos da nova versão:

![tarefa5-2]()


## Tarefa 6
Este código recebe um número N como entrada e calcula as raízes da expressão (z-2)^N=3. Calcula alpha e rho, e então a e b tal que z = a+bi. Por fim, escreve na tela os resultados e os formata.

````fortran
      write(*,*) 'De N'
      read(*,*) iN
      k=0
      pi = 4.*atan(1.0)

      rho = 3. ** (1./iN)

      do k = 1,iN
        alpha = (2.*k*pi)/iN
        a = (rho * cos(alpha)) + 2.
        b = rho * sin(alpha)
        write(*,1) 'z', ' = ', a, ', ', b, 'i'
1       format(a1, a3, f10.6, a2, f10.6, a1) 
      end do

      end
````

Abaixo testes para N de 1 a 7:

![tarefa6]()

## Tarefa 7
Esse programa calcula o volume de uma esfera de raio 1 e d dimensões. Primeiro ele recebe o número d de entrada. Então o programa gera 2 números aleatórios e faz a norma deles para verificar se o ponto está dentro da esfera. Isso é repetido M vezes. A razão entre a quantidade de pontos dentro da esfera e do total de pontos gerados é o volume em um quadrante. Por fim, o resultado é multiplicado pelo número de quadrantes da dimensão para obter o volume. Quanto maior o número M, maior a precisão.

````fortran
      integer d
      write(*,*) 'De d'
      read(*,*) d
      M = 999999
      dentro = 0
      total = 0
      do i = 1,M
      anorma = 0
        do j = 1,d
          anorma = anorma + rand(0)**2
        end do
               
        anorma = sqrt(anorma)
        if (anorma .LE. 1) then
          dentro = dentro +1
        end if
        total = total +1
      end do
      volume = (dentro)/(total)*(2.0d0**d)
      write(*,*) 'O Volume é', volume

      end
````

Abaixo, exemplos para 2, 3 e 4 dimensões:

![tarefa7]()

## Tarefa 8
Esse programa calcula de outra forma o volume de uma esfera de raio R e dimensão d. Além disso, salva em um arquivo o volume da dimensão d e de dimensões inferiores a d por meio de um loop.

````fortran
      integer d
      write(*,*) 'De R e d, respectivamente'
      read(*,*) R, d
      pi = 4.*atan(1.0)
      open(unit=2, file='dimensoes-esferas')

      do idim = 2,d
        volume = 0
        exp = real(idim)
        volume = ((pi**(exp/2))/gamma((exp/2)+1.0))*(R**exp)
        write(2,*) idim, volume
      end do
      
      close(2)

      end
````

Com o resultado do programa, podemos fazer um gráfico:

![grafico-1-13836963]()

